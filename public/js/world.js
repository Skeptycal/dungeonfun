// Generated by CoffeeScript 1.10.0
(function() {
  var World, exports, graph, heap, perlin, randInt;

  perlin = require('./third-party/perlin.js');

  graph = require('./graph.coffee');

  heap = require('./heap.coffee');

  randInt = function(x) {
    return Math.floor(Math.random() * x);
  };

  World = (function() {
    World.prototype.TILE_SIZE = 50;

    World.prototype.CELL_EMPTY = 0;

    World.prototype.CELL_WALL = 1;

    World.prototype.CELL_ROOM = 2;

    World.prototype.CELL_DOOR = 3;

    World.prototype.CELL_HALLWAY = 6;

    function World() {
      this.map = new graph.Graph();
    }

    World.prototype.getTile = function(tx, ty) {
      var l, t;
      l = tx * this.TILE_SIZE;
      t = ty * this.TILE_SIZE;
      return this.map.getRect(l, t, this.TILE_SIZE, this.TILE_SIZE);
    };

    World.prototype.makeTile = function(tx, ty) {
      var b, l, r, rooms, t;
      l = tx * this.TILE_SIZE;
      r = (tx + 1) * this.TILE_SIZE;
      t = ty * this.TILE_SIZE;
      b = (ty + 1) * this.TILE_SIZE;
      rooms = this.makeRooms(t, r, b, l);
      return this.makeHallways(t, r, b, l, rooms);
    };

    World.prototype.loadTile = function(tx, ty, content) {
      var b, k, l, r, ref, ref1, results, row, t, x, y;
      l = tx * this.TILE_SIZE;
      r = (tx + 1) * this.TILE_SIZE;
      t = ty * this.TILE_SIZE;
      b = (ty + 1) * this.TILE_SIZE;
      results = [];
      for (y = k = ref = t, ref1 = b; ref <= ref1 ? k <= ref1 : k >= ref1; y = ref <= ref1 ? ++k : --k) {
        row = content[y - t];
        results.push((function() {
          var m, ref2, ref3, results1;
          results1 = [];
          for (x = m = ref2 = l, ref3 = r; ref2 <= ref3 ? m <= ref3 : m >= ref3; x = ref2 <= ref3 ? ++m : --m) {
            results1.push(this.map.set(x, y, row != null ? row[x - l] : void 0));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.makeRooms = function(T, R, B, L) {
      var b, count, current, i, k, l, len, m, o, ok, other, q, r, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, room, roomCollision, rooms, rx, ry, s, t, u, v, w, x, y;
      rooms = [];
      roomCollision = function(tuple1, tuple2, pad) {
        var b1, b2, l1, l2, r1, r2, t1, t2;
        if (pad == null) {
          pad = 1;
        }
        t1 = tuple1[0], r1 = tuple1[1], b1 = tuple1[2], l1 = tuple1[3];
        t2 = tuple2[0], r2 = tuple2[1], b2 = tuple2[2], l2 = tuple2[3];
        if (b1 < t2 - pad) {
          return false;
        }
        if (t1 > b2 + pad) {
          return false;
        }
        if (r1 < l2 - pad) {
          return false;
        }
        if (l1 > r2 + pad) {
          return false;
        }
        return true;
      };
      for (i = k = 1, ref = Math.floor(this.TILE_SIZE * this.TILE_SIZE / 300); 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        while (true) {
          l = L + randInt(R - L);
          t = T + randInt(B - T);
          r = l + 6 + randInt(12);
          b = t + 3 + randInt(10);
          if (l <= L || t <= T) {
            continue;
          }
          if (r >= R - 1) {
            continue;
          }
          if (b >= B - 1) {
            continue;
          }
          current = [t, r, b, l];
          ok = true;
          for (m = 0, len = rooms.length; m < len; m++) {
            other = rooms[m];
            if (roomCollision(current, other)) {
              ok = false;
              break;
            }
          }
          if (ok) {
            rooms.push(current);
            break;
          }
        }
      }
      for (i = o = 0, ref1 = rooms.length - 1; 0 <= ref1 ? o <= ref1 : o >= ref1; i = 0 <= ref1 ? ++o : --o) {
        room = rooms[i];
        t = room[0], r = room[1], b = room[2], l = room[3];
        for (y = q = ref2 = t, ref3 = b; ref2 <= ref3 ? q <= ref3 : q >= ref3; y = ref2 <= ref3 ? ++q : --q) {
          for (x = s = ref4 = l, ref5 = r; ref4 <= ref5 ? s <= ref5 : s >= ref5; x = ref4 <= ref5 ? ++s : --s) {
            this.map.set(x, y, this.CELL_ROOM);
          }
        }
        for (x = u = ref6 = l, ref7 = r; ref6 <= ref7 ? u <= ref7 : u >= ref7; x = ref6 <= ref7 ? ++u : --u) {
          this.map.set(x, t, this.CELL_WALL);
          this.map.set(x, b, this.CELL_WALL);
        }
        for (y = v = ref8 = t + 1, ref9 = b - 1; ref8 <= ref9 ? v <= ref9 : v >= ref9; y = ref8 <= ref9 ? ++v : --v) {
          this.map.set(l, y, this.CELL_WALL);
          this.map.set(r, y, this.CELL_WALL);
        }
        count = 1 + randInt((r - l) * 2 / 10);
        for (w = 1, ref10 = count; 1 <= ref10 ? w <= ref10 : w >= ref10; 1 <= ref10 ? w++ : w--) {
          rx = l + 1 + randInt(r - l - 1);
          ry = t + 1 + randInt(b - t - 1);
          switch (randInt(4)) {
            case 0:
              x = rx;
              y = t;
              break;
            case 1:
              x = r;
              y = ry;
              break;
            case 2:
              x = rx;
              y = b;
              break;
            case 3:
              x = l;
              y = ry;
          }
          this.map.set(x, y, this.CELL_DOOR);
        }
      }
      return rooms;
    };

    World.prototype.makeHallways = function(T, R, B, L, rooms) {
      var a, b, filter, findDoors, hallwayPoints, heuristic, i, j, k, len, m, noise, o, other, p, path, r, ref, ref1, ref2, ref3, ref4, results, room, x, x1, x2, y, y1, y2;
      noise = new perlin.SimplexNoise({
        random: function() {
          return 0.123;
        }
      });
      heuristic = (function(_this) {
        return function(p1, p2) {
          var d1, d2, n;
          if (p2.value === _this.CELL_HALLWAY) {
            return 0;
          } else {
            d1 = Math.abs(p2.x - p1.x);
            d2 = Math.abs(p2.y - p1.y);
            n = Math.floor(noise.noise(p1.x / 15, p1.y / 15) * 20);
            return d1 + d2 + n;
          }
        };
      })(this);
      filter = (function(_this) {
        return function(node) {
          var x;
          x = node.value;
          return !x || x === _this.CELL_EMPTY || x === _this.CELL_DOOR || x === _this.CELL_HALLWAY;
        };
      })(this);
      findDoors = (function(_this) {
        return function(room) {
          var b, doors, k, l, m, r, ref, ref1, ref2, ref3, t, x, y;
          t = room[0], r = room[1], b = room[2], l = room[3];
          doors = [];
          for (x = k = ref = l, ref1 = r; ref <= ref1 ? k <= ref1 : k >= ref1; x = ref <= ref1 ? ++k : --k) {
            if (_this.map.get(x, t) === _this.CELL_DOOR) {
              doors.push([x, t]);
            }
            if (_this.map.get(x, b) === _this.CELL_DOOR) {
              doors.push([x, b]);
            }
          }
          for (y = m = ref2 = t, ref3 = b; ref2 <= ref3 ? m <= ref3 : m >= ref3; y = ref2 <= ref3 ? ++m : --m) {
            if (_this.map.get(l, y) === _this.CELL_DOOR) {
              doors.push([l, y]);
            }
            if (_this.map.get(r, y) === _this.CELL_DOOR) {
              doors.push([r, y]);
            }
          }
          return doors;
        };
      })(this);
      hallwayPoints = [];
      for (i = k = 0, ref = rooms.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        j = i;
        while (j === i) {
          j = randInt(rooms.length);
        }
        room = rooms[i];
        other = rooms[j];
        a = findDoors(room);
        b = findDoors(other);
        if (!a.length || !b.length) {
          continue;
        }
        ref1 = a[0], x1 = ref1[0], y1 = ref1[1];
        ref2 = b[0], x2 = ref2[0], y2 = ref2[1];
        path = this.map.astar(x1, y1, x2, y2, filter, heuristic);
        for (m = 0, len = path.length; m < len; m++) {
          p = path[m];
          this.map.setPoint(p, this.CELL_HALLWAY);
          hallwayPoints.push(p);
        }
      }
      results = [];
      for (i = o = 1, ref3 = Math.floor(this.TILE_SIZE * this.TILE_SIZE / 600); 1 <= ref3 ? o <= ref3 : o >= ref3; i = 1 <= ref3 ? ++o : --o) {
        ref4 = hallwayPoints[randInt(hallwayPoints.length)], x1 = ref4[0], y1 = ref4[1];
        x2 = void 0;
        r = Math.floor(this.TILE_SIZE * .2);
        while (!x2) {
          x = x1 - r + randInt(r * 2);
          y = y1 - r + randInt(r * 2);
          if (!this.map.get(x, y)) {
            x2 = x;
            y2 = y;
          }
        }
        path = this.map.astar(x1, y1, x2, y2, filter, heuristic);
        results.push((function() {
          var len1, q, results1;
          results1 = [];
          for (q = 0, len1 = path.length; q < len1; q++) {
            p = path[q];
            results1.push(this.map.setPoint(p, this.CELL_HALLWAY));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.connectTiles = function(tx1, ty1, tx2, ty2) {
      var PADDING, S, choices, dir, filter, k, len, len1, m, obj, p, p1, p2, path, ref, ref1, results, search, t1p, t2p;
      S = this.TILE_SIZE;
      PADDING = 10;
      if (Math.abs((tx2 - tx1) + (ty2 - ty1)) !== 1) {
        console.warn('Tried to connect to non-adjacent tiles');
        return;
      }
      if (ty1 < ty2) {
        dir = 'V';
      } else if (ty1 > ty2) {
        dir = 'V';
        ref = [tx2, ty2, tx1, ty1], tx1 = ref[0], ty1 = ref[1], tx2 = ref[2], ty2 = ref[3];
      } else if (tx1 < tx2) {
        dir = 'H';
      } else if (tx1 > tx2) {
        dir = 'H';
        ref1 = [tx2, ty2, tx1, ty1], tx1 = ref1[0], ty1 = ref1[1], tx2 = ref1[2], ty2 = ref1[3];
      }
      search = (function(_this) {
        return function(a, b, direction, swap) {
          var end, i, j, k, m, points, ref2, ref3, ref4, ref5, ref6, ref7, start, value, x, y;
          if (direction > 0) {
            start = a * S + PADDING;
            end = a * S + S;
          } else {
            start = a * S + S - 1 - PADDING;
            end = a * S;
          }
          for (i = k = ref2 = start, ref3 = end; ref2 <= ref3 ? k <= ref3 : k >= ref3; i = ref2 <= ref3 ? ++k : --k) {
            points = [];
            for (j = m = ref4 = b * S, ref5 = b * S + S; ref4 <= ref5 ? m <= ref5 : m >= ref5; j = ref4 <= ref5 ? ++m : --m) {
              if (swap) {
                ref6 = [j, i], x = ref6[0], y = ref6[1];
              } else {
                ref7 = [i, j], x = ref7[0], y = ref7[1];
              }
              value = _this.map.get(x, y);
              if (value === _this.CELL_HALLWAY || value === _this.CELL_DOOR) {
                points.push([x, y]);
              }
            }
            if (points.length) {
              return points;
            }
          }
        };
      })(this);
      if (dir === 'H') {
        t1p = search(tx1, ty1, -1, false);
        t2p = search(tx2, ty2, 1, false);
      }
      if (dir === 'V') {
        t1p = search(ty1, tx1, -1, true);
        t2p = search(ty2, tx2, 1, true);
      }
      if (!t1p || !t2p) {
        console.warn('Could not join tiles - one tile must be missing');
        return;
      }
      p1 = t1p[randInt(t1p.length)];
      choices = new heap.BinaryHeap(function(obj) {
        return obj.distance;
      });
      for (k = 0, len = t2p.length; k < len; k++) {
        p2 = t2p[k];
        choices.push({
          x: p2[0],
          y: p2[1],
          distance: (p2[0] - p1[0]) + (p2[1] - p1[1])
        });
      }
      obj = choices.pop();
      if (!obj) {
        console.warn('Could not join tiles - no points on t2', tx1, ty1, tx2, ty2);
        return;
      }
      p2 = [obj.x, obj.y];
      if (!(p1 != null ? p1.length : void 0) || !(p2 != null ? p2.length : void 0)) {
        console.warn('Could not join tiles - missing points', tx1, ty1, tx2, ty2);
        return;
      }
      filter = (function(_this) {
        return function(node) {
          var x;
          x = node.value;
          return !x || x === _this.CELL_EMPTY || x === _this.CELL_DOOR || x === _this.CELL_HALLWAY;
        };
      })(this);
      path = this.map.astar(p1[0], p1[1], p2[0], p2[1], filter);
      results = [];
      for (m = 0, len1 = path.length; m < len1; m++) {
        p = path[m];
        results.push(this.map.setPoint(p, this.CELL_HALLWAY));
      }
      return results;
    };

    return World;

  })();

  if (typeof exports === "undefined" || exports === null) {
    exports = this;
  }

  exports.World = World;

}).call(this);
